# GraphQL Layer Refactor Design

## Problem Statement

Three issues in the current GraphQL layer:

1. **`gql/client.ts` is a 2,284-line monolith.** Every consumer imports the full file — all 30+ operations, inline GQL strings, assertion functions, and type definitions. For a CLI tool this adds measurable startup latency. The file also mixes concerns: transport, types, validation, query execution, response mapping, and the `GithubClient` facade.

2. **`gql/generated/common-types.ts` doesn't follow `.generated` naming.** It is generated by `graphql-codegen` (used as `baseTypesPath` in `codegen.ts`), but all other generated files use the `.generated.ts` extension. This is confusing — it looks hand-written.

3. **`graphql-capability-adapter.ts` uses a ~350-line if-chain.** Every new capability requires adding a new `if (capabilityId === "...")` block with identical boilerplate. The `Pick<>` type annotation listing every method is also manually maintained.

Additionally, ~22 operations in `client.ts` use inline GQL template strings instead of proper `.graphql` files + codegen. These should be migrated to codegen for consistency and type safety.

## Design

### 1. Split `client.ts` into domain modules

New file structure under `packages/core/src/gql/`:

```text
gql/
  transport.ts          # GraphqlTransport, GraphqlClient, createGraphqlClient, createTokenTransport, resolveGraphqlUrl
  types.ts              # All *Input and *Data type exports (pure types, zero runtime)
  assertions.ts         # All assert* and helper functions (assertRepoInput, assertNonEmptyString, etc.)
  github-client.ts      # GithubClient interface + createGithubClient + createGithubClientFromToken factories
  domains/
    repo.ts             # runRepoView
    issue-queries.ts    # runIssueView, runIssueList, runIssueCommentsList
    issue-mutations.ts  # runIssueCreate, runIssueUpdate, runIssueClose, runIssueReopen, runIssueDelete,
                        # runIssueLabelsUpdate, runIssueLabelsAdd, runIssueAssigneesUpdate,
                        # runIssueMilestoneSet, runIssueCommentCreate, runIssueLinkedPrsList,
                        # runIssueRelationsGet, runIssueParentSet, runIssueParentRemove,
                        # runIssueBlockedByAdd, runIssueBlockedByRemove
    pr-queries.ts       # runPrView, runPrList, runPrReviewsList, runPrDiffListFiles, runPrMergeStatus
    pr-mutations.ts     # runPrCommentsList (filtering logic), runReplyToReviewThread,
                        # runResolveReviewThread, runUnresolveReviewThread
  client.ts             # DELETED (or kept as a thin re-export barrel for backwards compat during migration)
```

**Key rules:**
- `transport.ts` has zero domain knowledge — only the raw GraphQL execution concern.
- `types.ts` is pure `type` exports — no runtime cost.
- `assertions.ts` contains all input validation helpers.
- Each `domains/*.ts` file imports from `transport.ts`, `types.ts`, `assertions.ts`, and the relevant `.generated.ts` SDK modules.
- `github-client.ts` imports from domain modules and assembles the `GithubClient` facade.

**Public API impact:** `packages/core/src/index.ts` currently re-exports `GithubClient`, `GraphqlClient`, `GraphqlTransport`, `TokenClientOptions`, `createGithubClient`, `createGithubClientFromToken`, `createGraphqlClient`. These will come from `github-client.ts` and `transport.ts` instead of `client.ts`. No breaking changes to consumers.

### 2. Rename `common-types.ts` to `common-types.generated.ts`

Update `codegen.ts`:
```ts
baseTypesPath: "../generated/common-types.generated.js",
```

Then regenerate. All `.generated.ts` operation files will update their import paths automatically.

### 3. Migrate inline GQL strings to codegen

The following operations currently use inline template strings in `client.ts` instead of `.graphql` files:

- `PR_COMMENTS_LIST_QUERY` (already has `pr-comments-list.graphql` — needs verification)
- `PR_COMMENT_REPLY_MUTATION` (already has `pr-comment-reply.graphql`)
- `PR_COMMENT_RESOLVE_MUTATION` (already has `pr-comment-resolve.graphql`)
- `PR_COMMENT_UNRESOLVE_MUTATION` (already has `pr-comment-unresolve.graphql`)
- `PR_MERGE_STATUS_QUERY` — needs new `.graphql` file
- `REVIEW_THREAD_STATE_QUERY` — needs new `.graphql` file
- `ISSUE_CREATE_REPOSITORY_ID_QUERY` + `ISSUE_CREATE_MUTATION` (already has `issue-create.graphql`)
- `ISSUE_UPDATE_MUTATION` (already has `issue-update.graphql`)
- `ISSUE_CLOSE_MUTATION` (already has `issue-close.graphql`)
- `ISSUE_REOPEN_MUTATION` (already has `issue-reopen.graphql`)
- `ISSUE_DELETE_MUTATION` (already has `issue-delete.graphql`)
- `ISSUE_LABELS_UPDATE_MUTATION` (already has `issue-labels-update.graphql`)
- `ISSUE_LABELS_ADD_MUTATION` — needs new `.graphql` file or extend existing
- `ISSUE_ASSIGNEES_UPDATE_MUTATION` (already has `issue-assignees-update.graphql`)
- `ISSUE_MILESTONE_SET_MUTATION` (already has `issue-milestone-set.graphql`)
- `ISSUE_LABELS_LOOKUP_QUERY` — needs new `.graphql` file
- `ISSUE_ASSIGNEES_LOOKUP_QUERY` — needs new `.graphql` file
- `ISSUE_MILESTONE_LOOKUP_QUERY` — needs new `.graphql` file
- `ISSUE_COMMENT_CREATE_MUTATION` (already has `issue-comment-create.graphql`)
- `ISSUE_LINKED_PRS_LIST_QUERY` (already has `issue-linked-prs-list.graphql`)
- `ISSUE_RELATIONS_GET_QUERY` (already has `issue-relations-get.graphql`)
- `ISSUE_PARENT_LOOKUP_QUERY` — needs new `.graphql` file
- `ISSUE_PARENT_SET_MUTATION` (already has `issue-parent-set.graphql`)
- `ISSUE_PARENT_REMOVE_MUTATION` (already has `issue-parent-remove.graphql`)
- `ISSUE_BLOCKED_BY_ADD_MUTATION` (already has `issue-blocked-by-add.graphql`)
- `ISSUE_BLOCKED_BY_REMOVE_MUTATION` (already has `issue-blocked-by-remove.graphql`)

**Strategy:** For operations that already have `.graphql` files with codegen output, switch the domain module to use the generated SDK instead of the inline string. For operations without `.graphql` files, create them first, run codegen, then use the SDK.

After migration, all inline GQL template strings in `client.ts` are removed. Every operation goes through codegen.

### 4. Registry-driven capability dispatch

Replace the if-chain in `graphql-capability-adapter.ts` with a handler registry.

Each domain module exports a handler registration function:

```ts
// gql/domains/issue-queries.ts
import type { GraphqlHandler } from "../capability-registry.js"

export const issueQueryHandlers: Record<string, GraphqlHandler> = {
  "issue.view": (client, params) => client.fetchIssueView(params as IssueViewInput),
  "issue.list": (client, params) => client.fetchIssueList(withDefaultFirst(params) as IssueListInput),
  "issue.comments.list": (client, params) => client.fetchIssueCommentsList(params as IssueCommentsListInput),
}
```

Central registry in `gql/capability-registry.ts`:

```ts
export type GraphqlHandler = (
  client: GithubClient,
  params: Record<string, unknown>,
) => Promise<unknown>

const handlers = new Map<string, GraphqlHandler>()

export function registerGraphqlHandlers(entries: Record<string, GraphqlHandler>): void {
  for (const [id, handler] of Object.entries(entries)) {
    handlers.set(id, handler)
  }
}

export function getGraphqlHandler(capabilityId: string): GraphqlHandler | undefined {
  return handlers.get(capabilityId)
}
```

Then `graphql-capability-adapter.ts` shrinks to:

```ts
export async function runGraphqlCapability(
  client: GithubClient,
  capabilityId: string,
  params: Record<string, unknown>,
): Promise<ResultEnvelope> {
  try {
    const handler = getGraphqlHandler(capabilityId)
    if (!handler) return unsupportedGraphqlCapability(capabilityId)
    const data = await handler(client, params)
    return normalizeResult(data, "graphql", { capabilityId, reason: "CARD_PREFERRED" })
  } catch (error: unknown) {
    const code = mapErrorToCode(error)
    return normalizeError(
      { code, message: error instanceof Error ? error.message : String(error), retryable: isRetryableErrorCode(code) },
      "graphql",
      { capabilityId, reason: "CARD_PREFERRED" },
    )
  }
}
```

The `GraphqlCapabilityId` union type can be derived from the registry keys or kept as a manually maintained union for type safety at call sites.

## Non-goals

- Changing the `ResultEnvelope` contract
- Changing the operation card YAML format
- Adding new capabilities
- Changing the CLI adapter

## Testing Strategy

- All existing tests continue to pass unchanged (the refactor is internal).
- New unit tests for `transport.ts` and `assertions.ts` in isolation.
- Verify `pnpm run ci` passes after each phase.
- Verify `pnpm run ghx:gql:check` passes after codegen migration.
